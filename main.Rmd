---
title: "Random Forest in R"
author: "Victoria Scholl"
date: "4/8/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)

library(dplyr)
library(ggplot2)
library(randomForest)
library(knitr)
library(devtools)
library(geoNEON)
library(sp)           
library(swfscMisc)    
library(rgdal)
library(rgeos)
library(taxize)
library(stringr)

# set working directory to neon-veg in local environment
#setwd("~/github/neon-veg")

# path to directory containing NEON l1 Woody Vegetation data 
main_path <- "~/Documents/NEON/SJER/NEON_struct-woody-plant/" 

# specify output directory path and filename of output shapefile to be written
out_dir <- "~/github/random-forest/output/"

# load local functions written in external R files. 
# source("locate_woody_veg.R")
# source("woody_df_to_shp.R")
# source("merge_vst_tables.R")
# source("get_vst_crs.R")
# source("list_tiles_with_plants.R")
# source("apply_area_threshold.R")
# source("polygon_overlap.R")
# source("get_poly.R")
source("~/github/neon-veg/check_create_dir.R")
```


## NEON woody vegetation structure data product 

The following information is available in the [NEON User Guide to Woody Plant Vegetation Structure (NEON.DP1.10098)](http://data.neonscience.org/documents/10179/2237401/NEON_vegStructure_userGuide_vA/b390b73d-b259-46d8-9522-58fd72f12f8e):

Trees >10 cm diameter are mapped are mapped as points (offsets from a reference pointID; see table vst_mapping); small diameter trees and shrubs are not mapped but are iden - fied according to the subplot or nested subplot in which they are located (see tables vst_apparen ndividual and vst_shrubgroup) as are non-woody plants (see table nst_perinidividual). 

The individualID (NEON.PLA.D##.######) is a linking variable that  es vegeta on structure measurements and
associated metadata to the following associated data products:

The Woody Plant Vegetation Structure data product is comprised of four related tables:

**vst_perplotperyear** - One record is created for each plotID visited at a site during a given eventID. Recorded metadata include presence/absence of various woody growth forms, and nestedSubplotArea used to measure each growth form (if applicable).

**vst_mappingandtagging** - One or more records expected for each tagged woody individual (individualID) for all  me. A subset of tagged individuals are also mapped. Corrections to taxonID or mapped loca on through  me will result in duplicate individualIDs. In the case of duplicates, users are advised to retain the record with the latest date. Non-woody individuals that are also mapped and/or tagged (e.g., cac  at some sites, small palms, etc.) are also recorded in vst_mappingandtagging.

**vst_apparent individual** - For each unique woody individualID recorded in vst_mappingandtagging, technicians create at least one record in vst_apparen ndividual for each eventID. Multiple records per individualID are created for multibole individuals of the following growthForms: small tree, sapling, single shrub, small shrub. To scale up measurements from individuals to the plot-scale, per growthForm measurement areas are linked by plotID and eventID in vst_perplotperyear.

*Shape* appears only to be recorded for shrubs. 

According to the NEON documentation (NEON.DOC.000987), "Species information may not be informative with respect to assigning growth form. For example, Toxicodendron spp. commonly exist as lianas, small shrubs, and shrub groups." For this reason, growth form was not included as a predictor variable. 

```{r merge_veg_structure}
# create output directory if it does not exist 
check_create_dir(out_dir)

# loop through folders of field data with different dates
dirs <- list.dirs(path = main_path )
dirs <-dirs[ grepl("NEON.D17.SJER", dirs) ]


first_loop <- 1 # loop counter
for (woody_path in dirs){
  
  # mapping and tagging table (contains stem locations)
  woody_mapping_path <- paste(woody_path, 
                              list.files(path = woody_path, 
                                         pattern = "mappingandtagging"), 
                              sep="/")
  
  # apparent individual table (contains height and crown diameter)
  woody_individual_path <- paste(woody_path, 
                                 list.files(path = woody_path, 
                                            pattern = "apparentindividual"), 
                                 sep="/")
  
  # load both data tables 
  # calculate mapped UTM locations of plants from distance/azimuth
  woody_mapping <- read.csv(woody_mapping_path)
  woody_individual <- read.csv(woody_individual_path)
  
  # rename the date column in vst_mapping to differentiate it
  # from the "date" column in vst_individual.
  # the latter will be used to assess the most recent entries
  names(woody_mapping)[names(woody_mapping) == 'date'] <- 'date.mapping'
  
  # match mapped stems from "vst_mappingandtagging" with structure data 
  # from "vst_apparentindividual" based on individualID 
  merged <- merge(woody_mapping,
                  woody_individual,
                  by="individualID")
  
  # combine woody veg structure data to a single data frame 
  if (first_loop == 1){
    woody_all <- merged
    woody_mapping_all <- woody_mapping
    woody_individual_all <- woody_individual
    first_loop <- 0
    
  } else {
    woody_all <- rbind(woody_all, merged)
    woody_mapping_all <- rbind(woody_mapping_all, woody_mapping)
    woody_individual_all <- rbind(woody_individual_all, woody_individual)
  }
}

# remove duplicate entries; keep most recent
merged <- woody_all %>% 
  group_by(individualID) %>%
  slice(which.max(as.Date(date)))

# write merged vegetation structure tables to file 
write.csv(merged, file = paste(out_dir,"vst_merged.csv"))

# only keep complete entries with the metrics of interest 
woody <- merged[complete.cases(merged$taxonID) &
                  complete.cases(merged$scientificName) & 
                  complete.cases(merged$height) &  
                  complete.cases(merged$maxCrownDiameter) & 
                  #complete.cases(merged$stemDiameter) & 
                  complete.cases(merged$growthForm),]

# keep only the relevant columns 

```


```{r species_table}

# Manual lookup of common names 
manu_df <- data.frame(matrix("", ncol = 0, nrow = 16))

manu_df <- manu_df %>%
  mutate(commonNames = c("Unknown",
                 "California buckeye", #AECA
                 "Mariposa manzanita", #ARVIM
                 "Buckbrush", #CECU
                 "Chaparral whitethorn", #CELE2
                 "Jimsonweed", #DAWR2
                 "California buckthorn", #FRCAC7
                 "Silver lupine", #LUAL4
                 "California foothill pine", #PISA2
                 "Blue oak", #QUDO
                 "Interior live oak", #QUWI2
                 "Buckthorn", #RHAMNA
                 "Hollyleaf redberry", #RHIL
                 "Blue elderberry", #SANIC5
                 "Threadleaf ragwort", #SEFL3
                 "Poison Oak" #TODI
                  ),
         taxonID = c("2PLANT",
                     "AECA",
                     "ARVIM",
                     "CECU",
                     "CELE2",
                     "DAWR2",
                     "FRCAC7",
                     "LUAL4",
                     "PISA2",
                     "QUDO",
                     "QUWI2",
                     "RHAMNA",
                     "RHIL",
                     "SANIC5",
                     "SEFL3",
                     "TODI"))

woody_test <- woody %>%
  mutate(treeORshrub = ifelse(grepl("tree", growthForm), 
                      "tree", "shrub"),
         sciNameShort = word(scientificName, 1, 2)) %>%
  group_by(taxonID, sciNameShort, treeORshrub) %>%
  summarise(total = n()) %>% 
  ungroup() %>%
  inner_join(manu_df, by = "taxonID") %>%
  select(total, taxonID, sciNameShort, commonNames, treeORshrub)

# growthForm %in% c("multi-bole tree", "single bole tree","small tree")

#  mutate(sciNameShort = word(scientificName, 1, 2),
#         commonName = sci2comm(scinames = sciNameShort, db = "itis"))

kable(woody_test)
```


```{r explore_data, eval=FALSE}
# TESTING using table with common names 
ggplot(aes(x = commonNames, y = total, fill = treeORshrub), data = woody_test) + 
  geom_bar(stat="identity") + 
  labs(y = "Total # of plants", x = "Common name") + 
  ggtitle("Number of plants per species") +
  scale_fill_manual(name = "Growth Type",
                      labels = c("shrub", "tree"),
                      values = c("grey", "darkgreen")) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey10",
                                        linetype = 3,
                                        size = .1))

ggplot(data = woody_test, aes(x = taxonID)) +
  geom_boxplot(data = woody, aes(y = height))


```

```{r eval=FALSE}

# histogram scientific name 
ggplot(aes(taxonID, fill = scientificName), data = woody) + 
  geom_bar() + 
  ggtitle("Histogram of Taxon IDs") + 
  labs(x = "Taxon ID", y = "Number of samples") + 
  scale_fill_discrete(name = "Taxon ID")



# height
ggplot(data = woody, aes(taxonID, height, fill = taxonID)) +
  geom_boxplot() + 
  ggtitle("Height distributions across taxon IDs") + 
  labs(x = "Taxon ID", y = "Height (m)") +
  scale_fill_discrete(name = "Taxon ID")

# stem diameter 
ggplot(aes(taxonID, stemDiameter, fill = taxonID), data = woody) +
  geom_boxplot() + 
  ggtitle("Stem diameter distributions across taxon IDs") + 
  labs(x = "Taxon ID", y = "Stem diamater (cm)") + 
  scale_fill_discrete(name = "Taxon ID")

# max crown diameter
ggplot(aes(taxonID, maxCrownDiameter, fill = taxonID), data = woody) +
  geom_boxplot() + 
  ggtitle("Maximum Crown Diameter distributions across taxon IDs") + 
  labs(x = "Taxon ID", y = "Max crown diameter (m)") + 
  scale_fill_discrete(name = "Taxon ID")

# growth form
ggplot(aes(taxonID, growthForm, fill = taxonID), data = woody) +
  geom_boxplot() + 
  ggtitle("Growth Form distributions across taxon IDs") + 
  labs(x = "Taxon ID", y = "Growth Form") + 
  scale_fill_discrete(name = "Taxon ID")
```



## Random Forest 

Sources of useful tutorials for the randomForest function in R: 

 - [trevorstephens](http://trevorstephens.com/kaggle-titanic-tutorial/r-part-5-random-forests/) 
 - [kaggle](https://www.kaggle.com/mrisdal/exploring-survival-on-the-titanic)

Features (predictor variables) and class labels (response variable) must be provided in a data frame. 

The training and test sets must be separated. Training samples can be chosen by randomly selecting *n* of the input samples. 
(However, running the randomForest function returns an error when there are classes present in the test set factor levels)


```{r eval=FALSE}

# further filter data drame for only columns of interest
woody.features <- woody %>% 
          select(growthForm, 
                 plantStatus, 
                 stemDiameter, 
                 height, 
                 maxCrownDiameter, 
                 taxonID)

# separate training and test sets
train=sample(1:nrow(woody.features),200)
woody.train <- woody.features[train,]
woody.train <- droplevels(woody.train)

# set the random seed in R for reproducibility
set.seed(408)

# taxon ID is the response variable
# all other variables are used as predictors
woody.rf <- randomForest(taxonID ~ ., 
                         data = woody.train,
                         importance = TRUE,
                         ntree = 1000) 

varImpPlot(woody.rf)

plot(woody.rf)

print(woody.rf)

```

