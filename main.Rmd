---
title: "Random Forest in R"
author: "Victoria Scholl"
date: "4/8/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)

library(dplyr)
library(ggplot2)
library(randomForest)
library(knitr)
library(devtools)
library(geoNEON)
library(sp)           
library(swfscMisc)    
library(rgdal)
library(rgeos)
library(taxize)
library(stringr)
library(caret)

# set working directory to neon-veg in local environment
#setwd("~/github/neon-veg")

# path to directory containing NEON l1 Woody Vegetation data 
main_path <- "~/Documents/NEON/SJER/NEON_struct-woody-plant/" 

# specify output directory path and filename of output shapefile to be written
out_dir <- "~/github/random-forest/output/"

# load local functions written in external R files. 
# source("locate_woody_veg.R")
# source("woody_df_to_shp.R")
# source("merge_vst_tables.R")
# source("get_vst_crs.R")
# source("list_tiles_with_plants.R")
# source("apply_area_threshold.R")
# source("polygon_overlap.R")
# source("get_poly.R")
source("~/github/neon-veg/check_create_dir.R")
```


## NEON woody vegetation structure data product 

The following information is available in the [NEON User Guide to Woody Plant Vegetation Structure (NEON.DP1.10098)](http://data.neonscience.org/documents/10179/2237401/NEON_vegStructure_userGuide_vA/b390b73d-b259-46d8-9522-58fd72f12f8e):

Trees >10 cm diameter are mapped are mapped as points (offsets from a reference pointID; see table vst_mapping); small diameter trees and shrubs are not mapped but are iden - fied according to the subplot or nested subplot in which they are located (see tables vst_apparen ndividual and vst_shrubgroup) as are non-woody plants (see table nst_perinidividual). 

The individualID (NEON.PLA.D##.######) is a linking variable that  es vegeta on structure measurements and
associated metadata to the following associated data products:

The Woody Plant Vegetation Structure data product is comprised of four related tables:

**vst_perplotperyear** - One record is created for each plotID visited at a site during a given eventID. Recorded metadata include presence/absence of various woody growth forms, and nestedSubplotArea used to measure each growth form (if applicable).

**vst_mappingandtagging** - One or more records expected for each tagged woody individual (individualID) for all  me. A subset of tagged individuals are also mapped. Corrections to taxonID or mapped loca on through  me will result in duplicate individualIDs. In the case of duplicates, users are advised to retain the record with the latest date. Non-woody individuals that are also mapped and/or tagged (e.g., cac  at some sites, small palms, etc.) are also recorded in vst_mappingandtagging.

**vst_apparent individual** - For each unique woody individualID recorded in vst_mappingandtagging, technicians create at least one record in vst_apparen ndividual for each eventID. Multiple records per individualID are created for multibole individuals of the following growthForms: small tree, sapling, single shrub, small shrub. To scale up measurements from individuals to the plot-scale, per growthForm measurement areas are linked by plotID and eventID in vst_perplotperyear.

*Shape* appears only to be recorded for shrubs. 

According to the NEON documentation (NEON.DOC.000987), "Species information may not be informative with respect to assigning growth form. For example, Toxicodendron spp. commonly exist as lianas, small shrubs, and shrub groups." For this reason, growth form was not included as a predictor variable. 

```{r merge_veg_structure}
# create output directory if it does not exist 
check_create_dir(out_dir)

# loop through folders of field data with different dates
dirs <- list.dirs(path = main_path )
dirs <-dirs[ grepl("NEON.D17.SJER", dirs) ]


first_loop <- 1 # loop counter
for (woody_path in dirs){
  
  # mapping and tagging table (contains stem locations)
  woody_mapping_path <- paste(woody_path, 
                              list.files(path = woody_path, 
                                         pattern = "mappingandtagging"), 
                              sep="/")
  
  # apparent individual table (contains height and crown diameter)
  woody_individual_path <- paste(woody_path, 
                                 list.files(path = woody_path, 
                                            pattern = "apparentindividual"), 
                                 sep="/")
  
  # load both data tables 
  # calculate mapped UTM locations of plants from distance/azimuth
  woody_mapping <- read.csv(woody_mapping_path)
  woody_individual <- read.csv(woody_individual_path)
  
  # rename the date column in vst_mapping to differentiate it
  # from the "date" column in vst_individual.
  # the latter will be used to assess the most recent entries
  names(woody_mapping)[names(woody_mapping) == 'date'] <- 'date.mapping'
  
  # match mapped stems from "vst_mappingandtagging" with structure data 
  # from "vst_apparentindividual" based on individualID 
  merged <- merge(woody_mapping,
                  woody_individual,
                  by="individualID")
  
  # combine woody veg structure data to a single data frame 
  if (first_loop == 1){
    woody_all <- merged
    woody_mapping_all <- woody_mapping
    woody_individual_all <- woody_individual
    first_loop <- 0
    
  } else {
    woody_all <- rbind(woody_all, merged)
    woody_mapping_all <- rbind(woody_mapping_all, woody_mapping)
    woody_individual_all <- rbind(woody_individual_all, woody_individual)
  }
}

# remove duplicate entries; keep most recent
merged <- woody_all %>% 
  group_by(individualID) %>%
  slice(which.max(as.Date(date)))

# write merged vegetation structure tables to file 
write.csv(merged, file = paste(out_dir,"vst_merged.csv"))

# only keep complete entries with the metrics of interest 
woody <- merged[complete.cases(merged$taxonID) &
                  complete.cases(merged$scientificName) & 
                  complete.cases(merged$height) &  
                  complete.cases(merged$maxCrownDiameter) & 
                  #complete.cases(merged$stemDiameter) & 
                  complete.cases(merged$growthForm),]

# keep only the relevant columns 

```


```{r species_table}

# Manual lookup of common names 
manu_df <- data.frame(matrix("", ncol = 0, nrow = 16))

manu_df <- manu_df %>%
  mutate(commonNames = c("Unknown",
                 "California buckeye", #AECA
                 "Mariposa manzanita", #ARVIM
                 "Buckbrush", #CECU
                 "Chaparral whitethorn", #CELE2
                 "Jimsonweed", #DAWR2
                 "California buckthorn", #FRCAC7
                 "Silver lupine", #LUAL4
                 "California foothill pine", #PISA2
                 "Blue oak", #QUDO
                 "Interior live oak", #QUWI2
                 "Buckthorn", #RHAMNA
                 "Hollyleaf redberry", #RHIL
                 "Blue elderberry", #SANIC5
                 "Threadleaf ragwort", #SEFL3
                 "Poison Oak" #TODI
                  ),
         taxonID = c("2PLANT",
                     "AECA",
                     "ARVIM",
                     "CECU",
                     "CELE2",
                     "DAWR2",
                     "FRCAC7",
                     "LUAL4",
                     "PISA2",
                     "QUDO",
                     "QUWI2",
                     "RHAMNA",
                     "RHIL",
                     "SANIC5",
                     "SEFL3",
                     "TODI"))

woody_test <- woody %>%
  mutate(treeORshrub = ifelse(grepl("tree", growthForm), 
                      "tree", "shrub"),
         sciNameShort = word(scientificName, 1, 2)) %>%
  group_by(taxonID, sciNameShort, treeORshrub) %>%
  summarise(total = n()) %>% 
  ungroup() %>%
  inner_join(manu_df, by = "taxonID") %>%
  select(total, taxonID, sciNameShort, commonNames, treeORshrub)

# growthForm %in% c("multi-bole tree", "single bole tree","small tree")

#  mutate(sciNameShort = word(scientificName, 1, 2),
#         commonName = sci2comm(scinames = sciNameShort, db = "itis"))

kable(woody_test)
```


```{r explore_data}
# TESTING using table with common names 
ggplot(aes(x = commonNames, y = total, fill = treeORshrub), data = woody_test) + 
  geom_bar(stat="identity") + 
  labs(y = "Total # of plants", x = "Common name") + 
  ggtitle("Number of plants per species") +
  scale_fill_manual(name = "Growth Type",
                      labels = c("shrub", "tree"),
                      values = c("grey", "darkgreen")) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey10",
                                        linetype = 3,
                                        size = .1))

ggplot(data = woody_test, aes(x = taxonID)) +
  geom_boxplot(data = woody, aes(y = height))
```

According to the histogram, some species have very few samples in the data set.
The data set will be filtered to maintain only species that have >15 samples.

## Random Forest 

Sources of useful tutorials for the randomForest function in R: 

 - [trevorstephens](http://trevorstephens.com/kaggle-titanic-tutorial/r-part-5-random-forests/) 
 - [kaggle](https://www.kaggle.com/mrisdal/exploring-survival-on-the-titanic)
 - [keyrus blog](http://blog.keyrus.co.uk/alteryxs_r_random_forest_output_explained.html)

Features (predictor variables) and class labels (response variable) must be provided in a data frame. 

The training and test sets must be separated. Training samples can be chosen by randomly selecting *n* of the input samples. 
(However, running the randomForest function returns an error when there are classes present in the test set factor levels)

```{r}

# keep only the species with "greater than" (gt) 20 samples
woody_gt <- woody %>%
                group_by(taxonID) %>% 
                  filter(n()>20)

# convert output labels to categorical
woody_gt$taxonID <- factor(woody_gt$taxonID)
woody_gt$growthForm <- factor(woody_gt$growthForm)
woody_gt$plantStatus <- factor(woody_gt$plantStatus)

# further filter data drame for only columns of interest
woody_input <- woody_gt %>% 
          select(growthForm, 
                 plantStatus, 
                 height, 
                 maxCrownDiameter, 
                 taxonID) %>% 
          na.omit()

# set the random seed in R for reproducibility
set.seed(14)

# LOOCV using caret package 
# define training control
train_control <- trainControl(method="LOOCV")
# train the model
model <- train(taxonID~., data=woody_input, trControl=train_control, method="rf")
# summarize results
print(model)

# plot confusion matrix 
# get every 1/3 rows for mtry=2
model.2 = model$pred[seq(1, nrow(model$pred), 3), ]

confusion_matrix <- as.data.frame(table(model.2$pred, model.2$obs))
ggplot(data = confusion_matrix,
       mapping = aes(x = Var1,
                     y = Var2)) +
  geom_tile(aes(fill = Freq)) +
  geom_text(aes(label = sprintf("%1.0f", Freq)), vjust = 1) +
  scale_fill_gradient(low = "blue",
                      high = "red",
                      trans = "log") +
  labs(x = "Predicted taxon ID", y = "Actual taxon ID")
```





################## extra code

```{r filtered_hist}

woody_gt20 <- woody %>%
                group_by(taxonID) %>% 
                  filter(n()>20)

# histogram of remaining species 
woody_test20 <- woody_gt20 %>%
  mutate(treeORshrub = ifelse(grepl("tree", growthForm), 
                      "tree", "shrub"),
         sciNameShort = word(scientificName, 1, 2)) %>%
  group_by(taxonID, sciNameShort, treeORshrub) %>%
  summarise(total = n()) %>% 
  ungroup() %>%
  inner_join(manu_df, by = "taxonID") %>%
  select(total, taxonID, sciNameShort, commonNames, treeORshrub)
ggplot(aes(x = commonNames, y = total, fill = treeORshrub), data = woody_test20) + 
  geom_bar(stat="identity") + 
  labs(y = "Total # of plants", x = "Common name") + 
  ggtitle("Number of plants per species") +
  scale_fill_manual(name = "Growth Type",
                      labels = c("shrub", "tree"),
                      values = c("grey", "darkgreen")) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        panel.background = element_blank(),
        panel.grid.major = element_line(color = "grey10",
                                        linetype = 3,
                                        size = .1))
```

```{r RF_manual}

# convert output labels to categorical
woody_gt20$taxonID <- factor(woody_gt20$taxonID)
woody_gt20$growthForm <- factor(woody_gt20$growthForm)
woody_gt20$plantStatus <- factor(woody_gt20$plantStatus)

# further filter data drame for only columns of interest
woody_features <- woody_gt20 %>% 
          select(growthForm, 
                 plantStatus, 
                 height, 
                 maxCrownDiameter, 
                 taxonID) %>% 
          na.omit()

# separate training and test sets
# train
train=sample(1:nrow(woody_features),212)
woody.train <- woody_features[train,]
woody.train <- droplevels(woody.train)
# test
woody.test <- woody_features[-train,]
woody.test <- droplevels(woody.train)

# set the random seed in R for reproducibility
set.seed(408)

# taxon ID is the response variable
# all other variables are used as predictors
rf_model <- randomForest(taxonID ~ ., 
                         data = woody.train,
                         importance = TRUE,
                         ntree = 500) 

# summary of model
print(rf_model)

# show error as a funxtion of numTrees  
# OOB (black solid line) for overall error
# colored lines show each class error 
plot(rf_model)
legend('topright', colnames(rf_model$err.rate), col=1:6, fill=1:6)


# Get variable importance 
varImpPlot(rf_model)
importance <- importance(rf_model)
varImportance <- data.frame(Variables = row.names(importance), 
                            Importance = round(importance[ ,'MeanDecreaseGini'],2))

# Create a rank variable based on importance
rankImportance <- varImportance %>%
  mutate(Rank = paste0('#',dense_rank(desc(Importance))))

# Use ggplot2 to visualize the relative importance of variables
ggplot(rankImportance, aes(x = reorder(Variables, Importance), 
    y = Importance, fill = Importance)) +
  geom_bar(stat='identity') + 
  geom_text(aes(x = Variables, y = 0.5, label = Rank),
    hjust=0, vjust=0.55, size = 4, colour = 'red') +
  labs(x = 'Variables') +
  coord_flip() 





# Predict using the test set
prediction <- predict(rf_model, woody.test)

# Save the solution to a dataframe with two columns: PassengerId and Survived (prediction)
solution <- data.frame(taxonID = woody.test$taxonID, Predicted = prediction)

# Write the solution to file
write.csv(solution, file = 'rf_mod_Solution.csv', row.names = F)

# confusion matrix 
# https://stackoverflow.com/questions/21589991/plot-a-confusion-matrix-with-color-and-frequency-in-r
table(solution$taxonID, solution$Predicted)
rf_model$confusion


#cm_table <- table(solution$taxonID, solution$Predicted)
#plot(cm_table, main="Taxon ID Confusion Matrix", xlab="TEST")
```

```{r RF_manual2}
# keep only the species with "greater than" (gt) 20 samples
woody_gt <- woody %>%
                group_by(taxonID) %>% 
                  filter(n()>20)

# convert output labels to categorical
woody_gt$taxonID <- factor(woody_gt$taxonID)
woody_gt$growthForm <- factor(woody_gt$growthForm)
woody_gt$plantStatus <- factor(woody_gt$plantStatus)

# further filter data drame for only columns of interest
woody_input <- woody_gt %>% 
          select(growthForm, 
                 plantStatus, 
                 height, 
                 maxCrownDiameter, 
                 taxonID) %>% 
          na.omit()

# set the random seed in R for reproducibility
set.seed(14)

# loop through N, number of plant observations 
N <- nrow(woody_gt)

# keep track of true vs. predicted labels 
truth_labels <- woody_gt$taxonID
predicted_labels <- matrix(data=NA, nrow=N)

for (n in 1:N){
  print(n)
  
  # create test set (observation n)
  # and training set (N observations without n) 
  test <- woody_input[n,-which(names(woody_input) == "taxonID")]
  test <- droplevels(test)
  test_label <- droplevels(woody_input[n,]$taxonID)
  
  training <- woody_input[-n,]
  training <- droplevels(training)
  
  # set the factor levels to be the same for the test and train sets
  # to avoid an error
  common <- intersect(names(training), names(test)) 
  for (p in common) { if (class(training[[p]]) == "factor") { levels(test[[p]]) <- levels(training[[p]]) } } 
  
  # train RF using N-1 observations 
  rf_model <- randomForest(taxonID ~ ., 
                         data = training,
                         importance = TRUE,
                         ntree = 1000) 
  
  # predict species of test observation, n
  prediction <- predict(rf_model, test)
  
  # keep track of truth label and prediction 
  predicted_labels[n] <- as.character(prediction)

}

# Create confusion matrix 
table(truth_labels, predicted_labels) 

cm <- confusionMatrix(as.factor(predicted_labels), truth_labels)
cm$table

# plot confusion matrix
confusion_matrix <- as.data.frame(table(predicted_labels, truth_labels))
ggplot(data = confusion_matrix,
       mapping = aes(x = predicted_labels,
                     y = truth_labels)) +
  geom_tile(aes(fill = Freq)) +
  geom_text(aes(label = sprintf("%1.0f", Freq)), vjust = 1) +
  scale_fill_gradient(low = "blue",
                      high = "red",
                      trans = "log") +
  labs(x = "Predicted taxon ID", y = "True taxon ID")
```


```{r eval=FALSE}

# histogram scientific name 
ggplot(aes(taxonID, fill = scientificName), data = woody) + 
  geom_bar() + 
  ggtitle("Histogram of Taxon IDs") + 
  labs(x = "Taxon ID", y = "Number of samples") + 
  scale_fill_discrete(name = "Taxon ID")



# height
ggplot(data = woody, aes(taxonID, height, fill = taxonID)) +
  geom_boxplot() + 
  ggtitle("Height distributions across taxon IDs") + 
  labs(x = "Taxon ID", y = "Height (m)") +
  scale_fill_discrete(name = "Taxon ID")

# stem diameter 
ggplot(aes(taxonID, stemDiameter, fill = taxonID), data = woody) +
  geom_boxplot() + 
  ggtitle("Stem diameter distributions across taxon IDs") + 
  labs(x = "Taxon ID", y = "Stem diamater (cm)") + 
  scale_fill_discrete(name = "Taxon ID")

# max crown diameter
ggplot(aes(taxonID, maxCrownDiameter, fill = taxonID), data = woody) +
  geom_boxplot() + 
  ggtitle("Maximum Crown Diameter distributions across taxon IDs") + 
  labs(x = "Taxon ID", y = "Max crown diameter (m)") + 
  scale_fill_discrete(name = "Taxon ID")

# growth form
ggplot(aes(taxonID, growthForm, fill = taxonID), data = woody) +
  geom_boxplot() + 
  ggtitle("Growth Form distributions across taxon IDs") + 
  labs(x = "Taxon ID", y = "Growth Form") + 
  scale_fill_discrete(name = "Taxon ID")
```

